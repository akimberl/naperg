generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum SubscriptionType {
  FREE
  STANDARD
  PRO
}

enum Currency {
  RUR
  USD
  EUR
}

// Category is represented as tags with specific theme
// In future: category should have subcategories to specify the themes for Users
enum Category {
  SPORT
  TECHNOLOGY
  PROGRAMMING
  POLITICS
  RELIGION
  GLOBAL_WARMING
  PHILOSOPHY
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  password      String
  resetPasswordToken String
  dateResetPasswordRequest DateTime?
  validateEmailToken String
  isEmailValidated Boolean @default(false)
  lastLogin     DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userRole    UserRole     @default(USER)
  subscriptions Subscription[] // history of subscriptions
  feeds   Feed[]
  createdArticleSources ArticleSource[] @relation("CreatedArticleSources") // Only User with Admin role is able to create ArticleSources
  followingArticleSources ArticleSource[] @relation("FollowingArticleSources")
  articles UserArticleInteraction[]
}

model Subscription {
  id Int @id @default(autoincrement())
  type SubscriptionType @default(FREE)
  price Int // assuming that for MVP there will be only monthly prices. @TODO: think about monthly and annual pricing
  currency Currency @default(RUR)
  user User @relation(fields: [userId], references: [id])
  userId Int
  createdAt  DateTime    @default(now())
  expirationDate DateTime
  isCurrent Boolean // User should have only one subscrition with `isCurrent = true`

}

// Feed is a list of ArticleSources containing Articles created by User
// User creates Feed to read most interesting Articles from ArticleSources he chose to follow
model Feed {
  id Int @id @default(autoincrement())
  name String @unique
  author    User  @relation(fields: [authorId], references: [id])
  authorId  Int
  sources ArticleSource[]
}

// ArticleSource can be created by Admin. But mostly generated by automated script where ArticleSource are created and refreshed
model ArticleSource {
  id Int @id @default(autoincrement())
  name String @unique
  createdBy User @relation("CreatedArticleSources", fields: [authorId], references: [id]) // userRole should be only Admin
  authorId Int
  sourceUrl String
  articles Article[]
  keptInFeeds Feed[]
  follower User[] @relation("FollowingArticleSources")
}

// Article is created by function refreshAllArticleSources(). @TODO: create periodic job with refreshAllArticleSources function.
model Article {
  id         Int         @id @default(autoincrement())
  createdAt  DateTime    @default(now())
  title      String
  content    String
  source     ArticleSource        @relation(fields: [sourceId], references: [id])
  sourceId   Int
  readingUsers UserArticleInteraction[]
  categories Category[]
}

model UserArticleInteraction {
  user        User     @relation(fields: [userId], references: [id])
  userId      Int
  article    Article @relation(fields: [articleId], references: [id])
  articleId  Int

  isHidden Boolean
  isSavedLater Boolean
  hasRead Boolean

  @@id([userId, articleId])
}

// Model Table will be added in future releases
// Table will be created by User. User will be able to save articles to different tables to save most interesting ones
